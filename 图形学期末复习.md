# 图形学期末复习

## 第一章 绪论

### 1.图形与图像的区别？

图形由场景的几何模型和物理属性共同描述，其结果以数字图像的方式提供。而图像指计算机内以位图形式存放的亮度和颜色信息。

### 2.走样的原因和反走样的概念

对于光栅系统来说，只能用像素来近似描绘平滑的直线、多边形或其他图元，因此可能引起的**锯齿状或阶梯状的边界线问题**称为**走样**。用于**减少或消除这种现**象的技术称为**“反走样”**。

## 第二章 颜色模型

### 1.什么是与设备无关的颜色模型 

这类颜色模型是基于**人眼对色彩感知**的度量建立的数学模型，这些颜色模型主要用于计算和测量。

### 2.什么是与设备相关的颜色模型

以最常见的RGB模型为例。一组确定的RGB数值，在一个液晶屏上 显示，最终会作用到三色LED的电压上。这样一组值在**不同设备上解释时**，得到的颜色可能并不相同。

### 3.RGB和CMY颜色模型的比较

| 比较项       | RGB颜色模型                                            | CMY颜色模型                                             |
| ------------ | ------------------------------------------------------ | ------------------------------------------------------- |
| 三原色       | Red Green Blue                                         | Cyan(青) Magenta(品红) Yellow                           |
| 成色基本规律 | R + G = Y<br>R + B = M<br/>G + B = C<br/>R + G + B = W | Y + M = R<br/>C + Y = G<br/>C + M = B<br/>C + M + Y = K |
| 实质         | 色光相加光能量增大                                     | 色料混合光能量减少                                      |
| 效果         | 明度增大                                               | 明度减小                                                |
| 成色方式     | 视觉器官外：空间混合 静态混合<br/>视觉器官内：动态混合 | 色料掺合/透明色层叠合                                   |
| 补色关系     | 补色光相加越加越亮，形成白色                           | 补色料相加越加越暗，形成黑色                            |
| 主要应用     | 彩色电影、电视、测色计                                 | 彩色绘画、摄影、印刷印染                                |

### 4.哪些颜色模型是设备相关的，哪些是设备无关的。

设备相关：RGB、CMYK。

设备无关：XYZ、Lab。

## 第三章 物体表示

## 1.什么是建模坐标系，和世界坐标系的区别？

在计算机图形学中，常用的是空间坐标系，物体的几何描述与空间坐标系密切相关，对于相同的几何物理，选择不同的坐标系也会有不同的表示形式，选择空间坐标系使得**几何物体的表示最简单**，该坐标系称为建模坐标系。它是**模型自身的内部坐标系统**，所有几何点的位置都是相对于模型原点的。而世界坐标系的几何位置是相对于**世界原点**的。两者之间可以通过简单的线性变换进行转换。

## 2.描述OBJ数据结构。

OBJ文件由**一行行文本**组成，注释行以#开头，空格和空行可随意添加以提高可读性。有字的行都由一两个标记字母即**关键字Keyword开头**，可以说明这一行是什么数据类型。多行可以逻辑地连接在一起表示一行，方法是在每一行**最后添加连接符\\**。

(1)OBJ是一种**3D模型文件**，因此不包含动画、材质特性、贴图路径、动力学、粒子等信息。

(2)OBJ文件**主要支持多边形(Polygons)模型**。 虽然OBJ文件也支持曲线(Curves)、表面(Surfaces)、点组材质(Point Group Materials)，但Maya导出的OBJ文件并不包括这些信息。

(3)OBJ文件支持**三个点以上的面**，这一点很有用。

(4)OBJ文件支持**法线和贴图坐标**。贴图坐标信息可以存入OBJ文件中。

## 3.什么是BREP，其结构中包含哪些信息？

BREP即边界表示，它是几何造型中最成熟无二义的表示法。实体的边界同样是由面的并集来表示，而每个面又由它所在的曲面的定义加上其边界来表示，面的边界是边的并集，而边又由点来表示。边界表示按照体-面-环-边-点的层次，详细记录构成形体的所有几何元素的几何信息及其相互连接的拓扑关系。

## 4.半边数据结构是什么？

半边结构是一种高效、灵活的数据结构。它通过引入方向相反的半边，能够高效地表示几何体的邻域信息。然而，它需要较高的存储开销，适合在需要频繁查询和编辑拓扑关系的场景中使用。

需要存储三种信息：

1.每条半边存储以下信息：

- **起点（Start Vertex）**：该半边的起始顶点。
- **下一条半边（Next Half-Edge）**：当前半边在面中的下一个半边。
- **对偶半边（Twin Half-Edge）**：与当前半边方向相反的另一半边。
- **所属面（Face）**：半边所在的面。

2.顶点存储：

- 关联的一条半边。

3.面存储：

- 组成该面的某一条半边。

![image-20241207211624441](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207211624441.png)![image-20241207211634771](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207211634771.png)



## 5.多边形的优缺点

**优点：**

- 表示**简单**。
- 可以表示具有**任意拓扑**的物体。
- 可以表示具有**丰富细节**的物体。
- 大部分图形硬件支持多边形物体的**加速绘制**。

**缺点：**

- 逼近表示，**难以满足交互**时的放大要求。
- 难以用传统方法**修改**物体外形。
- 缺乏解析表达式，**几何属性计算困难**。
- 在表示复杂拓扑或丰富细节的物体时，**数据量庞大，各操作负担重**。

## 6.Bézier曲线优缺点

**优点：**

- 简单易用，数学公式简单。
- 控制点位置直接影响曲线形状，可以轻松修改曲线，形状仅与控制多边形有关。
- 可以表示各种复杂曲线形状。

**缺点：**

- 每个控制点都会影响整个曲线的形状，不方便局部调整
- 表示复杂形状时，需要将多条Bezier曲线光滑拼接起来。

## 7.NURBS曲线和B样条曲线的改进是什么？

B样条相比于Bezier的改进：曲线多项式独立于控制点数目，允许局部控制曲线或者曲面。

NURBS相比于B样条的改进：B样条不能精确表示二次曲面与平面的交线，NURBS曲线通过权因子来控制形状，每个顶点有一个权因子Wi，wi=1时就是B样条曲线，wi=0时对于的控制顶点对曲线形状没有影响，权越大越靠近控制点，为无穷时经过点R。

## 8.参数曲线的优缺点

**优点：**

- 参数表示是显式的：对于每一个参数值，可以直接计算曲面上的对应点。参数表示的物体可以方便转化为多边形逼近表示。
- 曲面上的几何量计算简便
- 特殊形式的参数表示的外形控制十分直观

**缺点：**

- 控制点管理困难
- 处理复杂形状具有局限性
- 计算量较大

## 9.细分曲面的原理

先创建出模型的大致轮廓，然后设置需要切割的点线面，即根据算法新增顶点，同时调整原有顶点以创建出更多的顶点。

## 10.细分曲面的作用

使得粗糙的多边形网格逼近光滑的曲面，生成分辨率更高的曲面。

## 11.Catmull-Clark subdivision

**创造新的点：**

Face Point(4边形)![image-20241207222349768](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207222349768.png)

Edge Point(v、w为边原来的两顶点，vF1、vF2为相邻面顶点)![image-20241207222524778](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207222524778.png)

New Vertex Point( α = 1 , β = 2)：假设有顶点v。Q是与v相邻的face point的平均值；n是v相邻边的个数，R是与v相邻的n条边的**中点**的平均值，那么新点v‘为![image-20241207222803986](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207222803986.png)

**产生新的边：**

FacePoint与包围他的边对应的边顶点VE相连。

每个NewVertexPoint与它相邻边上的VE相连。

## 12.有哪些常见的细分规则

Catmull-Clark，Doo-Sabin，Loop细分。

## 13.细分曲面的翼边存储

翼边存储边的信息相对较多。

对于**每条边**，存储其**所有**的两个顶点，**所有**的两个面，面左与之连接的**另外两条边**（三角形），面右与之连接的**另外两条边**。

对于**每个点**，存储其中的**任一**个边索引。

对于**每个面**，存储其中的**任一**个边索引。

![image-20241207224123243](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207224123243.png)

## 14.物体的CSG表示

CSG（Constructive Solid Geometry，构造实体几何）是一种用于表示复杂几何体的建模方法。它使用基本的几何**原语**（如立方体、球体、圆柱体等）和**布尔运算**（如并集、交集和差集）来构造复杂的几何形状。CSG树是一种用**二叉树**来表达 CSG 模型的结构化表示。

CSG树：通过一系列的**几何操作**（布尔运算和几何变换）将简单的**基本体素**（立方体、球、圆柱圆锥等）组合起来。

## 15.什么分形几何

从整体上看，分形几何图形是处处不规则的。但在不同尺度下，图形的规则性又是相同的，使用过程而不是方程对物体进行建模，是一种特别适用于描述大自然（具有自相似性，如山川、云朵和粒子运动等）的几何形态的学科。

![image-20241207231527965](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207231527965.png)

## 16.分形维数计算

描述分形对象细节的变化量，是对象粗糙性或细碎性的度量。

D = ln *n* / ln(*1/s*)，其中n是再分数目、s是缩放因子。

![image-20241207231823750](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207231823750.png) n = 4，s = 1/3的情形。

## 17.L-系统，如何能够用L系统绘制物体？

需定义：

- 语法规则：根据语法规则对字母进行迭代生成新的字符串。

![image-20241207232334646](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207232334646.png)![image-20241207232345119](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207232345119.png)

- 字符解释：将字符串中的字符解释为适当的几何体素，通过语法规则+字符解释可以得到一个基于语法规则生成的物体。

![image-20241207232351726](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207232351726.png)

生成结果![image-20241207232359278](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241207232359278.png)

## 第四章 pipeline

![img](https://img2020.cnblogs.com/blog/1544400/202111/1544400-20211107150945162-1780333474.jpg)

**CPU渲染：剔除工作（除去视锥体外部不需渲染的物体）、设置渲染顺序、打包操作**

**GPU渲染管线：顶点处理、图元装配、光栅化、片元处理、输出合并、帧缓存等。**

### 顶点处理

顶点着色器：输入进来的每个定点都会调用一次顶点着色器，主要执行**坐标转换**任务，**坐标转换是将顶点坐标从模型空间转换到齐次裁剪空间中**。

细分曲面着色器：对三角形进行细分来增加物体表面的三角形数量。

### 图元装配

裁剪：一些图元，它可能一部分位于摄像机视野内，另一部分在摄像机视野外部，外面这部分不需要进行渲染,可以将它裁剪掉. 例如，线段的两个顶点一个位于视椎体内而另一个位于视椎体外，那么位于外部的顶点将被裁剪掉，而且**在视椎体与线段的交界处产生新的顶点来代替视野外部的顶点**（在裁剪空间中进行）。

标准化设备坐标：在裁剪空间的基础上，进行**透视除法**`(perspective division)`后得到的坐标叫做NDC坐标，将坐标从裁剪空间的(-w,-w,w)变换为(-1,-1,1)，即除 w，获得NDC坐标是为了实现屏幕坐标的转换与硬件无关。

屏幕映射：屏幕映射（ScreenMapping）的任务是把每个图元的x和y坐标转换到屏幕坐标系（Screen Coordinates）下。屏幕坐标系是一个二维坐标系，它和我们用于显示画面的分辨率有很大关系。

### 光栅化

该阶段主要是将变换到屏幕空间的**图元离散化为片元**的过程。

三角形设置：需要计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。

三角形遍历：这一步的输出就是得到一个片元序列。需要注意的是，一个片元并不是真正意义上的像素，而是包含了很多状态的集合，这些状态用于计算每个像素的最终颜色。这些状态包括了（但不限于）它的屏幕坐标、深度值Z、顶点颜色，以及其他从几何阶段输出的顶点信息，例如法线、纹理坐标等。

### 片元着色器(Fragment Shader)

它最主要的任务就是着色,光栅化阶段实际上并不会影响屏幕上每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎样覆盖每个像素的。而每个片元就负责存储这样一系列数据。着色有两种最常见的技术，分别是**纹理贴图和光照技术**。

### 帧缓存（Frame Buffer）

可以简单理解为一个临时画布，GPU渲染完成的信息会存放在帧缓存区,等待使用，上述各种测试也是在帧缓冲区进行的。帧缓冲区主要包含**颜色缓冲区(Color Buffer)**和**深度缓冲区(Depth Buffer)**，深度缓冲区中深度值小的可以覆盖缓冲区中的内容。

### 总结

![img](https://img2020.cnblogs.com/blog/1544400/202111/1544400-20211107151655884-493995287.png)

## 第五章 变换

### 齐次坐标系及其作用

在二维和三维空间中，齐次坐标通过增加一个维度表示点的位置：![image-20241208001708400](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208001708400.png)

使用齐次坐标，所有的几何变换（平移、旋转、缩放、投影等）都可以用**矩阵乘法统一表示**。

普通坐标系下，平移无法用线性变换（矩阵乘法）表示，而齐次坐标通过引入额外维度 w，将平**移转化为矩阵乘法。**

### 二维平移、旋转、缩放矩阵

**平移：**

![image-20241208002029467](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208002029467.png)

**旋转：**针对坐标原点

![image-20241208002542334](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208002542334.png)

**缩放：**

![image-20241208002704347](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208002704347.png)

连续平移、连续旋转可加：

![image-20241208003226582](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208003226582.png)![image-20241208003232625](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208003232625.png)

连续缩放相乘：

![image-20241208003242028](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208003242028.png)

### 各种变换的作用

![image-20241208004025268](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208004025268.png)

模型变换：将局部模型放入场景。

视图变换：将场景调整为相机视角。

投影变换：将三维点投影到二维平面。

设备变换：归一化坐标到设备范围。

视口变换：映射到屏幕像素。

### 一点透视、两点透视、三点透视

![image-20241208013159801](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208013159801.png)投影矩阵几个pqr几个不为0则说明为几点透视

## 第六章 剪裁

### 二维以及三维裁剪在pipeline中的位置

![image-20241208013742116](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208013742116.png)

三维裁剪在**模型变换**或**取景变换**时进行，保证视窗体外的物体部分被裁剪掉。

二维裁剪在**设备变换**或**视窗变换**后进行（这时候才转换成二维坐标）。

### Cohen-Sutherland裁剪算法

![image-20241208014203859](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208014203859.png)

延长窗口将二维平面分成9个区域，![image-20241208014531239](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208014531239.png)

**对线段的操作：**

每条线段包含两个端点，各有一个编码。

情况1：两个端点都是**0000**编码，可显示

情况2：两端点的编码进行**&运算**结果不为**0**，直接丢弃![image-20241208014930172](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208014930172.png)

情况3：![image-20241208020304034](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208020304034.png)

例如A和B求按**位或**得到1111.因此它应该与**四条延长线或窗口线**都相交，这样需要按照一定的计算顺序进行和四条边进行求交点运算。这里求交按照固定的顺序来进行（左右下上或上下右左)。一条线段与窗口最多求交4次![image-20241208020331889](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208020331889.png)

获得交点CDEF。然后给交点进行编码继续分割在窗口内的线段部分。一次迭代，直到求得最后的EF这条线段部分。

### 中点分割算法

每次先求出中点![image-20241208020953832](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208020953832.png)

![image-20241208021011167](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208021011167.png)

保留存在交点的一部分，如图中应保留P和P1（即把P2 = P1），判断保留哪一个用以下公式

![image-20241208021138115](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208021138115.png)

![image-20241208021155551](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208021155551.png)

求交点：

![image-20241208021849832](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208021849832.png)

## 第七章 光栅化

### 区域填充算法及其递归函数实现

**区域**：已经表示成点阵的像素的集合（等待被赋予某种颜色）

**区域表示：**

- 内部表示（内部同色）：把给定区域**内部像素**枚举并着**同种颜色**，边界不能着上述颜色。
- 边界表示（边界同色）：**边界像素**着**同种颜色**，内部不能着上述颜色。

![image-20241208181613185](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208181613185.png)

**区域类型**：四连通（上下左右四个方向）or八连通（上下左右斜八个方向）。区分标准为看区域能否通过四连通从一个像素到任意区域内的像素。

![image-20241208181754063](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208181754063.png)

**种子填充递归算法：**

![image-20241208181825250](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208181825250.png)

![image-20241208181834228](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208181834228.png)

注意边界表示法判断条件为**不是边界像素的颜色**，因为要填充的永远是内部区域。

### 扫描线算法如何判断一个点在面内还是面外

单点判断方法：**射线法**

从当前像素发射一条不经过顶点的射线（**单方向**），计算射线与多边形的交点个数。

**内部为奇数**个交点，**外部为偶数**个交点。

扫描线算法判断：![image-20241208183649063](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208183649063.png)

先用扫描线构建出来交点序列，然后去判断这些序列位于多边形内部的情况，在对序列所在区段进行着色。（极值点按2个交点算，非极值点按1个或在扫描的时候阶段1像素）![image-20241208183817992](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208183817992.png)

### 分类的边表ET构建

![image-20241208184514069](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208184514069.png)

数据结构包含：

- ymax：上端点y坐标
- x：下端点x坐标
- dx：边斜率的倒数
- next：同类的下一条边的指针

看是否同类：看下端点的纵坐标，指相同分进i组，然后按x递增以及dx递增进行排序。（水平边不计入）

![image-20241208184634950](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208184634950.png)

![image-20241208184647339](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208184647339.png)

### 活化边链表AEL构建方法

太麻烦不看了

## 第八章 曲面消隐

### 图形空间算法及其特点

**图形空间算法框架：**从视点出发，**逐像素**发射一条射线，求取这条射线与对象空间中的第一个交点，用该点的颜色值作为视窗上该像素点的颜色值。

**特点：**

- 受分辨率的限制，无法超出视窗的分辨率
- 时间复杂度O(nN)，n为多边形数，N为像素
- 算法：z-buffer，scan line扫描线算法

### 对象空间算法

**对象空间算法框架：**逐对象通过优先级排序，优先级为距离视点的距离，优先级高的最后渲染，或通过优先级找到每个物体未被遮挡的部分。

**特点：**

- 适合精密CAD工程领域
- 时间复杂度O(n^2)
- 算法：后向面剔除或画家算法

### z-buffer算法及其优缺点

Z-buffer算法中有两个buffer。

Frame-buffer：原有的存储**图像像素颜色值**的帧缓存。

Z-buffer：存储像素的Z坐标（这里是以视点为原点）**最近的Z坐标的值**的buffer(会随时更新）。投影类型更适合平行投影。当然如果是透视投影计算会根据透视投影进行计算。Z-buffer上可以说存储的是场景的深度值也成为深度图。为什么需要存储深度值的这个buffer，那么就要明白z-buffer这个算法的基本思想了。要实现消隐，是不是就是要离我们视点近的物体遮挡远的物体，实现这样的效果。

**Z-buffer**算法的思想也正是如此，只画离视点更近的点就行了。

伪代码：

![image-20241208195707658](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208195707658.png)

初始化FrameBuffer为背景颜色

初始化Zbuffer为maxZ

对每一个多边形的每一个像素，计算其深度值pz并与当前这个像素的Zbuffer进行比较，若更小则替代。

**计算每点的深度值Z：插值法**![image-20241208200830548](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208200830548.png)

根据比例进行加减

![image-20241208200818379](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208200818379.png)

**优点：**

- 复杂度O(nN)
- 不需要物体排序
- 能够处理任何几何形状
- 可以使用硬件加速

**缺点：**

- 很占内存
- 受限于分辨率，存在走样
- 不容易处理透明物体

### 如何检测后向面

V为摄像机的视线（沿像素发射的射线），N为面法线

![image-20241208201745599](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208201745599.png)



![image-20241208201732289](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208201732289.png)

**计算面法线的方法：**

![image-20241208201806394](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208201806394.png)

### 画家算法原理及特性

在景物空间中预先计算物体上各多边形**可见性的优先级**（也就是根据排序给多边形赋予不同的优先级，可以是越远越低），然后再在图像空间中产生消隐图。细化深度排序算法可分为两步进行：（1）将多边形按深度进行排序：距视点近的优先级高，距视点远的优先级低。（2）**由优先级低的多边形开始**，逐个对多边形进行扫描转换。

类似画画的时候先画背景，再画前景。

根据深度值Z的范围进行判断是否重叠

- 若![image-20241208203639350](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208203639350.png)

- 若重叠，需要进行**五个判断**：

  - 第1多边形P和Q的***x*坐标**范围是否不重叠.
  - 第2多边形P和Q的***y*坐标**范围是否不重叠
  - 第3从视点看去，多边形P是否**完全位于Q的背面**
  - 第4从视点看去，多边形Q是否**完全位于P的同一侧**。
  - 第5多边形P和Q在***xy*平面上的投影是否不重叠**。 

  上述只要有一个成立就互不遮挡。

**特性：**

- 可能将具有正确深度顺序的多边形进行剖分，增大计算量。
- 可以看到三维物体的深度排序算法是依赖于视点位置来计算排序的，因此适合于固定视点的消隐。
- 视点变化的场合，难以满足实时性的要求。

### 二叉空间剖分树构建

![image-20241208210416155](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208210416155.png)

### 二叉空间剖分树遍历

放

### area subdivision算法原理

没看到相关内容

### 常用的消隐算法

Z-buffer，后面剔除，画家算法

## 第九章 真实感图形绘制

### 基础的光照模型

**Lambert漫反射模型：**

漫反射光是物体表面对入射光线吵各个方向的均匀反射，大小只与入射光的光亮度和入射方向有关，与漫反射光的反射方向无关。![image-20241208214147953](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208214147953.png)

与视点方向无关，与光源入射角（通过两个向量计算）、出射光亮度、漫反射率有关。最后加上泛光模型。

![image-20241208214353533](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208214353533.png)



**Phong镜面反射模型：**

![image-20241208214547813](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208214547813.png)

需要注意在一个区域内都可以观察到反光。

![image-20241208214709160](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208214709160.png)

cos可以通过单位R·V来计算。

反射向量R可以通过以下公式快速计算：![image-20241208214935566](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208214935566.png)

综合泛光和漫反射后：

![image-20241208215006961](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208215006961.png)

**Whitted模型：**

![image-20241208220743379](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208220743379.png)

![image-20241208220910543](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208220910543.png)

### 基础的明暗处理模型

**Flat Shading：**其依据局部光照明模型按每一个**多边形的法向**计算出一个颜色值C。将C赋给该多边形在屏幕上的投影所覆盖的全体像素。简单但粗糙。

**Gouraud Shading：**为多边形物体的每一个**顶点赋一个法向量**。利用局部光照明模型计算每一顶点处的光亮度。多边形内部各点处的光亮度值通过对多边形顶点处的光亮度的**双线性插值**得到。

**Phong Shading：**为多边形的每一个顶点都赋予一个法向量，多边形**内部各点处的法向量**则通过对多边形顶点处法向量的双线性插值得到。在每个点的明暗计算时利用Phong模型计算每一点的光亮度。

### 光线追踪算法步骤

Step1：从**视点**出发，通过屏幕上一像素点的中心向场景**发出一条射线**，并计算射线与场景种所有物体的交点。

Step2：将各交点沿光线方向排序，获得**离视点最近的交点**（消隐）。

Step3：根据**局部光照模型计算交点处颜色值Ic**，并沿着P所在物体的镜面反射方向和透射方向各**衍生出一条光线**（需有反射率或透射率）。

Step4：分别对**衍生出的光线递归**地执行前面步骤（类似于把这个点当作**新的视点**，看传过来的光亮有多少，所以需要看衍生光线与物体的交点），计算来自镜面反射和透射方向上周围环境对点P光亮度的贡献Is和It（递归计算Is和It）

![image-20241208222715748](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208222715748.png)

### 光线树生成过程

光线跟踪用树结构来表示这一光线递归生成过程，称之为光线树。通过光线跟踪可以递归的生成这个光线树，有了这个光线树，我们也就清晰化如何求取每个交点处的亮度值了。树的结点代表物体表面与跟踪线的交点。结点连线代表跟踪线。每个结点的**左儿子代表反射**产生的跟踪线（r），**右儿子代表透射**产生的跟踪线（t）。**后序算法遍历这颗光线跟踪树**，算出跟踪射线方向的光强，并按**两表面交点之间的距离进行衰减**后，传递给父结点。如此上递，最后得出P0点处的光强，亦即得到屏幕象素处的亮度。

### 终止条件

**条件1：**光线与环境中任何物体均不相交

**条件2：**被追踪光线返回的光亮度值贡献小于阈值

**条件3：**递归到了最大深度

### 光线追踪四类光线

Eye rays：从**视点出发**的视线

Shadow rays：从物体表面上的点**朝光源**发出

Reflected rays：从物体表面上的点沿**镜面反射方向**发出

Refracted rays：从物体表面上的点沿**投射方向**发出

![image-20241208223530957](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208223530957.png)

### 包含阴影的phone模型

![image-20241208223636777](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208223636777.png)

检测是否处于阴影之中：从交点向光源i发出一条测试光线R，检测R是否与物体相交，若相交这对于这个光源i来说处于阴影之中，则只包含泛光。

### 光线追踪加速技术

**包围盒：**

将场景中的所有表面按其空间位置关系分层次组织成树状结构。**根结点为整个场景**。**中间结点是空间位置较为接近的一组表面。叶结点为单个景物表面。**

当**光线与包围盒有交**时，才进行光线于其中所含景物面片求交运算。

![image-20241208223959359](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208223959359.png)![image-20241208224003269](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208224003269.png)

**空间分割：**

将**景物空间分割成一个个小的空间单元**。被跟踪的光线仅**与它所穿过空间单元**中所含物体表面进行**求交测试**。同时利用相邻空间单元的空间连贯性，使光线快速跨越空单元，迅速到达非空单元，求得光线与景物的第一个交点。

### 纹理分类

**按定义域：**

- 二维纹理
- 三维纹理

**按表现形式：**

- **颜色**纹理
- **几何**纹理
- **过程**纹理

### 纹理的两种映射方法、

**纹理扫描：**将纹理模式映射至物体表面，然后再进行投影变换映射至投影平面。

**像素次序扫描：**将投影平面的像素区域映射至物体表面，再映射至纹理空间。

### 常用的纹理反走样方法

前置滤波、超采样、Mipmap方法

### Mipmap映射方法原理

**预处理阶段**：生成纹理的多级分辨率版本。

**渲染阶段**：根据物体与视点的距离动态选择合适分辨率的纹理。

Mipmap 使用纹理的原始分辨率（称为 Level 0）作为起点，通过逐级降采样生成多个低分辨率的纹理版本。每一级纹理的分辨率是上一层的一半，直到生成 1×1 的纹理为止。

### 常用的三维纹理

**凹凸映射：**在不改变物体宏观几何的前提下，模拟物体表面粗糙的、褶皱的、凹凸不平的光照效果。：用纹理去修改物体的法向而不是颜色。物体表面的几何法向保持不变，我们仅仅改变光照明模型计算中的法向。

**法向映射：**利用法向纹理保证高质量的表面细节复现。先计算高精度模型的法向，将其保存在法向纹理中，再将法向纹理映射到低精度模型上进行光照计算。

**位移映射：**利用纹理改变物体表面上点的几何位置，获得很强的深度感和细节。依据与表面上点所对应的纹理值，沿表面法向偏移该点的几何位置。

### 辐射度系统方程

先将场景中每一物体的表面分解为互不重叠的小面片![image-20241208235519625](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241208235519625.png)

![image-20241209145016031](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209145016031.png)



### 辐射度算流程

![image-20241209144950500](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209144950500.png)

### Gathering方法和Shooting方法的区别

### 半影与本影区别

本影：假如这里场景中的一个点 P，如果它不被光源的任何一部分所照射到，就称为在本影区里。**本影就是不被任何光源所照到的区域。在阴影绘制时本影区应该是较为黑色的区域**。

半影：**半影是指只有部分光线到达的区域。相对于本影区，在绘制半影区时可以相对较明亮一些。**

![image-20241209004453449](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209004453449.png)

### Depth fail/pass计算方法

放

### 什么是LOD技术

放

### 三角形带方法点传输序列

放

### 三角形扇方法点传输序列

放

## 第十章 OpenGL

### 简单图形的绘制

![image-20241209145417116](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209145417116.png)

mode里可填内容

![image-20241209145500857](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209145500857.png)

设置颜色glColor4f(R, G, B, A透明度)

旋转glRotatef(角度, x, y, z)

清理颜色缓存glClear(GL_COLOR_BUFFER_BIT);

设置点的大小glPointSize

绘制矩形glRectf(A,B,C,D)

最后glFlush()强制绘图

![image-20241209150723741](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209150723741.png)![image-20241209150730767](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209150730767.png)

![image-20241209150739241](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209150739241.png)

### 设置光照场景

![image-20241209151541089](C:\Users\86186\AppData\Roaming\Typora\typora-user-images\image-20241209151541089.png)









